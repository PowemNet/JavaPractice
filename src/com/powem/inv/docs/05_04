1-



------------------------------------------------------------------------------------------------------------------------
2-

------------------------------------------------------------------------------------------------------------------------
3-
------------------------------------------------------------------------------------------------------------------------
4-

------------------------------------------------------------------------------------------------------------------------
5-

------------------------------------------------------------------------------------------------------------------------
6-
------------------------------------------------------------------------------------------------------------------------
7-
------------------------------------------------------------------------------------------------------------------------
8-
------------------------------------------------------------------------------------------------------------------------
9-

------------------------------------------------------------------------------------------------------------------------
10-

------------------------------------------------------------------------------------------------------------------------
11 -

------------------------------------------------------------------------------------------------------------------------
12-

------------------------------------------------------------------------------------------------------------------------
13 -

------------------------------------------------------------------------------------------------------------------------
14 -

------------------------------------------------------------------------------------------------------------------------
15 -

------------------------------------------------------------------------------------------------------------------------

16 - Rework from last week - brand new submission

You are developing a system to manage a retail store's inventory. Each product in the inventory
 has a unique product ID, a name, a category, a price, and a stock count. The system must
 allow quick retrieval of products by name and efficient sorting and searching based on price or stock levels.

Create the ProductInventorySystem class using a combination of Java's ArrayList and binary search
 algorithm to manage the product list. Implement features to add products, search products by name
 using binary search, and sort products by price or stock.

Detailed Method Requirements:

addProduct(String productId, String name, String category, double price, int stock): Adds a product to the inventory.

Product findProductByName(String name): Efficiently finds a product by its name using binary search.

List<Product> sortProductsByPrice(): Returns a list of products sorted by price.

List<Product> sortProductsByStock(): Returns a list of products sorted by stock level.



import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

public class ProductInventorySystem {
  public static class Product implements Comparable<Product> {
    private String productId;
    private String name;
    private String category;
    private double price;
    private int stock;

    public Product(String productId, String name, String category, double price, int stock) {
      if ((productId == null || productId.isEmpty()) && price == 0 && stock == 0) {
        this.name = name;
      } else {
        if (productId == null || productId.isEmpty()) {
          throw new IllegalArgumentException("Product ID cannot be null or empty.");
        }
        if (name == null || name.isEmpty()) {
          throw new IllegalArgumentException("Name cannot be null or empty.");
        }
        if (category == null || category.isEmpty()) {
          throw new IllegalArgumentException("Category cannot be null or empty.");
        }
        if (price < 0) {
          throw new IllegalArgumentException("Price cannot be negative.");
        }
        if (stock < 0) {
          throw new IllegalArgumentException("Stock cannot be negative.");
        }
        this.productId = productId;
        this.name = name;
        this.category = category;
        this.price = price;
        this.stock = stock;
      }
    }

    @Override
    public int compareTo(Product other) {
      return this.name.compareTo(other.name);
    }

    public String getName() {
      return name;
    }

    public double getPrice() {
      return price;
    }

    public int getStock() {
      return stock;
    }
  }

  private List<Product> products;

  public ProductInventorySystem() {
    this.products = new ArrayList<>();
  }

  public void addProduct(String productId, String name, String category, double price, int stock) {
    products.add(new Product(productId, name, category, price, stock));
    products.sort(Comparator.comparing(Product::getName));
  }

  public Product findProductByName(String name) {
    Comparator<Product> nameComparator = Comparator.comparing(Product::getName);
    int index = Collections.binarySearch(products, null, (prod, dummy) -> nameComparator.compare(prod, new Product("", name, "", 0, 0)));
    if (index >= 0) {
      return products.get(index);
    }
    throw new IllegalArgumentException("Product with specified name not found");
  }


  public List<Product> sortProductsByPrice() {
    List<Product> sortedList = new ArrayList<>(products);
    sortedList.sort(Comparator.comparingDouble(Product::getPrice));
    return sortedList;
  }

  public List<Product> sortProductsByStock() {
    List<Product> sortedList = new ArrayList<>(products);
    sortedList.sort(Comparator.comparingInt(Product::getStock));
    return sortedList;
  }
}

-- TESTS

public class Main {
  public static void main(String[] args) {
    ProductInventorySystem library = new ProductInventorySystem();

    //TEST
    library.addProduct("001", "How to be rich", "Business", 25.99, 50);

    try {
      library.addProduct("", "Java in Practice", "Programming", 15.99, 30);
      assert false;
    } catch (IllegalArgumentException e) {
      assert true;
    }
    //TEST_END

    //TEST
    try {
      library.addProduct("002", "Java in Practice", "Programming", -15.99, 30);
      assert false;
    } catch (IllegalArgumentException e) {
      assert true;
    }
    //TEST_END

    //TEST
    ProductInventorySystem.Product result = library.findProductByName("How to be rich");
    assert result.getName().equals("How to be rich");
    //TEST_END

    //TEST
    try {
      library.findProductByName("Non Existent");
      assert false;
    } catch (IllegalArgumentException e) {
      assert true;
    }
    //TEST_END

    //TEST
    library.addProduct("003", "C++ Demystified", "Programming", 29.99, 15);
    var sortedProducts = library.sortProductsByPrice();
    assert sortedProducts.get(0).getPrice() <= sortedProducts.get(1).getPrice();
    //TEST_END

    //TEST
    var sortedProducts2 = library.sortProductsByStock();
    assert sortedProducts2.get(0).getStock() <= sortedProducts2.get(1).getStock();
    //TEST_END
  }
}


------------------------------------------------------------------------------------------------------------------------

17 - rework

You are tasked with building a robust system for a social media platform that
 manages user relationships. The system should allow for efficiently checking direct
 friendships, discovering friends of friends, and finding common connections between users.

Create the SocialMediaConnectionManager class that uses a HashMap to represent a network
 of users and their connections. The class should support adding new friendships, checking
 if two users are directly connected, and finding both indirect connections and common friends.

Detailed Method Requirements:

addConnection(String userId1, String userId2): Establishes a bidirectional friendship between two users.

boolean areFriends(String userId1, String userId2): Checks if two users are directly connected.

Set<String> getFriendsOfFriends(String userId): Returns a set of users who are two degrees of separation away.

Set<String> getCommonConnections(String userId1, String userId2): Finds common friends between two users.

import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

public class SocialMediaConnectionManager {
  private Map<String, Set<String>> userConnections;

  public SocialMediaConnectionManager() {
    userConnections = new HashMap<>();
  }

  public void addConnection(String userId1, String userId2) {
    if (userId1 == null || userId1.isEmpty() || userId2 == null || userId2.isEmpty()) {
      throw new IllegalArgumentException("User IDs cannot be null or empty");
    }
    userConnections.computeIfAbsent(userId1, k -> new HashSet<>()).add(userId2);
    userConnections.computeIfAbsent(userId2, k -> new HashSet<>()).add(userId1);
  }

  public boolean areFriends(String userId1, String userId2) {
    if (userId1 == null || userId1.isEmpty() || userId2 == null || userId2.isEmpty()) {
      throw new IllegalArgumentException("User IDs cannot be null or empty");
    }
    Set<String> friends = userConnections.get(userId1);
    return friends != null && friends.contains(userId2);
  }

  public Set<String> getFriendsOfFriends(String userId) {
    if (userId == null || userId.isEmpty()) {
      throw new IllegalArgumentException("User ID cannot be null or empty");
    }
    Set<String> result = new HashSet<>();
    Set<String> directFriends = userConnections.getOrDefault(userId, Collections.emptySet());
    for (String friend : directFriends) {
      Set<String> friendsOfFriend = userConnections.getOrDefault(friend, Collections.emptySet());
      result.addAll(friendsOfFriend);
    }
    result.remove(userId);
    return result;
  }

  public Set<String> getCommonConnections(String userId1, String userId2) {
    if (userId1 == null || userId1.isEmpty() || userId2 == null || userId2.isEmpty()) {
      throw new IllegalArgumentException("User IDs cannot be null or empty");
    }
    Set<String> friends1 = userConnections.getOrDefault(userId1, Collections.emptySet());
    Set<String> friends2 = userConnections.getOrDefault(userId2, Collections.emptySet());
    Set<String> common = new HashSet<>(friends1);
    common.retainAll(friends2);
    return common;
  }
}

-- TESTS
import java.util.Set;

public class Main {
  public static void main(String[] args) {
    SocialMediaConnectionManager manager = new SocialMediaConnectionManager();

    //TEST
    manager.addConnection("user1", "user2");
    manager.addConnection("user2", "user3");
    //TEST_END

    //TEST
    try {
      manager.addConnection("user4", null);
      assert false;
    } catch (IllegalArgumentException e) {
      assert true;
    }
    //TEST_END

    //TEST
    assert manager.areFriends("user1", "user2");
    //TEST_END

    //TEST
    assert !manager.areFriends("user1", "user3");
    //TEST_END

    //TEST
    try {
      manager.areFriends("user1", null);
      ;
      assert false;
    } catch (IllegalArgumentException e) {
      assert true;
    }
    //TEST_END

    //TEST
    try {
      manager.areFriends("", "user2");
      ;
      assert false;
    } catch (IllegalArgumentException e) {
      assert true;
    }
    //TEST_END

    //TEST
    Set<String> friendsOfFriends = manager.getFriendsOfFriends("user1");
    assert friendsOfFriends.contains("user3");
    //TEST_END

    //TEST
    try {
      manager.getFriendsOfFriends(null);
      assert false;
    } catch (IllegalArgumentException e) {
      assert true;
    }
    //TEST_END

    //TEST
    manager.addConnection("user3", "user4");
    manager.addConnection("user2", "user4");
    Set<String> commonConnections = manager.getCommonConnections("user2", "user3");
    assert commonConnections.contains("user4");
  }
}


------------------------------------------------------------------------------------------------------------------------

18 - Rework from last week - brand new submission

You are tasked with creating a navigation system for a city that includes dynamic updates
 such as road closures and traffic jams. The system should provide users with the shortest
 path between two points in the city, adjusting routes based on real-time data.

Challenge:
Implement the CityNavigationSystem class using graph structures to represent the city's
 road network. The system should be able to add roads, update road statuses (open or closed),
 and compute the shortest path between two points using Dijkstra's algorithm.

Helper Method Requirements:

addRoad(String startPoint, String endPoint, int distance): Adds a bidirectional road between
two points with a specified distance.

updateRoadStatus(String startPoint, String endPoint, boolean isOpen): Updates the status of
a road (open or closed).

List<String> findShortestPath(String startPoint, String endPoint): Finds the shortest path
between two points considering only open roads.

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.PriorityQueue;
import java.util.Set;

public class CityNavigationSystem {
  private static class Road {
    String endPoint;
    int distance;
    boolean isOpen;

    Road(String endPoint, int distance, boolean isOpen) {
      if(distance <= 0 ) {
        throw new IllegalArgumentException("invalid distance");
      }
      this.endPoint = endPoint;
      this.distance = distance;
      this.isOpen = isOpen;
    }
  }

  private Map<String, List<Road>> cityMap;

  public CityNavigationSystem() {
    cityMap = new HashMap<>();
  }

  public void addRoad(String startPoint, String endPoint, int distance) {
    cityMap.computeIfAbsent(startPoint, k -> new ArrayList<>()).add(new Road(endPoint, distance, true));
    cityMap.computeIfAbsent(endPoint, k -> new ArrayList<>()).add(new Road(startPoint, distance, true));
  }

  public void updateRoadStatus(String startPoint, String endPoint, boolean isOpen) {
    if (cityMap.containsKey(startPoint)) {
      cityMap.get(startPoint).stream()
          .filter(road -> road.endPoint.equals(endPoint))
          .forEach(road -> road.isOpen = isOpen);
    }
    if (cityMap.containsKey(endPoint)) {
      cityMap.get(endPoint).stream()
          .filter(road -> road.endPoint.equals(startPoint))
          .forEach(road -> road.isOpen = isOpen);
    }
  }

  public List<String> findShortestPath(String startPoint, String endPoint) {
    if (!cityMap.containsKey(startPoint) || !cityMap.containsKey(endPoint)) {
      throw new IllegalArgumentException("Start or end point does not exist in the map");
    }

    Map<String, Integer> distances = new HashMap<>();
    Map<String, String> previous = new HashMap<>();
    Set<String> visited = new HashSet<>();
    PriorityQueue<String> queue = new PriorityQueue<>(Comparator.comparingInt(distances::get));

    distances.put(startPoint, 0);
    queue.add(startPoint);

    while (!queue.isEmpty()) {
      String current = queue.poll();
      if (current.equals(endPoint)) {
        break;
      }
      visited.add(current);

      for (Road road : cityMap.getOrDefault(current, Collections.emptyList())) {
        if (!road.isOpen || visited.contains(road.endPoint)) {
          continue;
        }
        int newDist = distances.getOrDefault(current, Integer.MAX_VALUE) + road.distance;
        if (newDist < distances.getOrDefault(road.endPoint, Integer.MAX_VALUE)) {
          distances.put(road.endPoint, newDist);
          previous.put(road.endPoint, current);
          queue.add(road.endPoint);
        }
      }
    }

    if (!previous.containsKey(endPoint)) {
      throw new IllegalArgumentException("No valid path found");
    }

    List<String> path = new ArrayList<>();
    for (String at = endPoint; at != null; at = previous.get(at)) {
      path.add(at);
    }
    Collections.reverse(path);
    return path;
  }
}

-- TESTS

import java.util.Arrays;
import java.util.List;

public class Main {
  public static void main(String[] args) {
    CityNavigationSystem navigationSystem = new CityNavigationSystem();

    //TEST
    navigationSystem.addRoad("A", "B", 5);
    navigationSystem.addRoad("B", "C", 10);
    navigationSystem.addRoad("A", "C", 15);

    navigationSystem.updateRoadStatus("A", "C", false);
    List<String> path = navigationSystem.findShortestPath("A", "C");
    assert path.equals(Arrays.asList("A", "B", "C"));
    //TEST_END

    //TEST
    try {
      navigationSystem.updateRoadStatus("B", "C", false);
      navigationSystem.findShortestPath("A", "C");
      assert false;
    } catch (IllegalArgumentException e) {
      assert true;
    }
    //TEST_END

    //TEST
    try {
      navigationSystem.findShortestPath("X", "Y");
      assert false;
    } catch (IllegalArgumentException e) {
      assert true;
    }
    //TEST_END

    //TEST
    try {
      navigationSystem.addRoad("C", "D", -1);
      assert false;
    } catch (IllegalArgumentException e) {
      assert true;
    }
    //TEST_END

    //TEST
    navigationSystem.updateRoadStatus("B", "C", true);
    List<String> path2 = navigationSystem.findShortestPath("A", "C");
    assert path2.equals(Arrays.asList("A", "B", "C"));
    //TEST_END
  }
}

------------------------------------------------------------------------------------------------------------------------

19 - Rework from last week - brand new submission

Create a secure storage system for messages where each message is
 stored in an encrypted format. The system should provide functionalities to add messages,
 retrieve them, and delete them securely, all while ensuring that the operations are performed efficiently.

Implement the SecureMessageStorage class using a combination of HashMap for storage and
 the Caesar Cipher encryption mechanism for encrypting the messages before
 storing them. The system should also support decryption for message retrieval.

Detailed Method Requirements:

addMessage(String id, String message): Encrypts and stores the message associated with a unique ID.

String getMessage(String id): Decrypts and retrieves the message associated with the given ID.

boolean deleteMessage(String id): Deletes the message associated with the given ID.


import java.util.HashMap;
import java.util.Map;

public class SecureMessageStorage {
  private Map<String, String> messages;
  private final int shift = 4;

  public SecureMessageStorage() {
    messages = new HashMap<>();
  }

  public void addMessage(String id, String message) {
    if (id == null || id.isEmpty()) {
      throw new IllegalArgumentException("ID cannot be null or empty.");
    }
    if (message == null) {
      throw new IllegalArgumentException("Message cannot be null.");
    }
    messages.put(id, encrypt(message));
  }

  public String getMessage(String id) {
    if (id == null || id.isEmpty()) {
      throw new IllegalArgumentException("ID cannot be null or empty.");
    }
    String encryptedMessage = messages.get(id);
    if (encryptedMessage == null) {
      throw new IllegalArgumentException("Message not found for given ID.");
    }
    return decrypt(encryptedMessage);
  }

  public boolean deleteMessage(String id) {
    if (id == null || id.isEmpty()) {
      throw new IllegalArgumentException("ID cannot be null or empty.");
    }
    if (messages.containsKey(id)) {
      messages.remove(id);
      return true;
    }
    return false;
  }

  private String encrypt(String message) {
    return shift(message, shift);
  }

  private String decrypt(String message) {
    return shift(message, -shift);
  }

  private String shift(String text, int shift) {
    shift = (shift % 26 + 26) % 26;
    StringBuilder encrypted = new StringBuilder();
    for (char character : text.toCharArray()) {
      if (character >= 'a' && character <= 'z') {
        character = (char) ((character - 'a' + shift) % 26 + 'a');
      } else if (character >= 'A' && character <= 'Z') {
        character = (char) ((character - 'A' + shift) % 26 + 'A');
      }
      encrypted.append(character);
    }
    return encrypted.toString();
  }

}


-- TESTS:
public class Main {
  public static void main(String[] args) {
    SecureMessageStorage storage = new SecureMessageStorage();

    //TEST
    storage.addMessage("001", "Hello World");
    String message = storage.getMessage("001");
    assert "Hello World".equals(message);
    //TEST_END

    //TEST
    try {
      storage.addMessage(null, "Test Message");
      assert false;
    } catch (IllegalArgumentException e) {
      assert true;
    }
    //TEST_END

    //TEST
    try {
      storage.addMessage("", "Test Message");
      assert false;
    } catch (IllegalArgumentException e) {
      assert true;
    }
    //TEST_END

    //TEST
    try {
      storage.addMessage("002", null);
      assert false;
    } catch (IllegalArgumentException e) {
      assert true;
    }
    //TEST_END

    //TEST
    try {
      storage.getMessage("003");
      assert false;
    } catch (IllegalArgumentException e) {
      assert true;
    }
    //TEST_END

    //TEST
    storage.addMessage("004", "Temporary Message");
    assert storage.deleteMessage("004");
    //TEST_END

    //TEST
    assert !storage.deleteMessage("999");
    //TEST_END

    //TEST
    try {
      storage.deleteMessage("");
      assert false;
    } catch (IllegalArgumentException e) {
      assert true;
    }
    //TEST_END

    //TEST
    try {
      storage.deleteMessage(null);
      assert false;
    } catch (IllegalArgumentException e) {
      assert true;
    }
    //TEST_END
  }
}
------------------------------------------------------------------------------------------------------------------------

20 - Rework from last week - brand new submission

Create a system for a social network that can detect and categorize different communities
or clusters of users based on their interactions and friendships. This system should help in targeted advertising,
content delivery, and enhancing user engagement by promoting community-specific activities and content.

Implement the CommunityDetector class that uses graph structures to represent the social network and applies the Louvain
method for community detection.

Helper Method Requirements:

addUser(String userId, List<String> friends): Adds a user and their list of friends to the network.

Map<String, Integer> detectCommunities(): Applies the Louvain method to detect communities and returns a mapping of user IDs
to their respective community identifiers.

List<String> getCommunityMembers(int communityId): Retrieves a list of all users belonging to a specific community.

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Queue;
import java.util.Set;

public class CommunityDetector {
  private Map<String, Set<String>> userGraph;
  private Map<String, Integer> communityMap;

  public CommunityDetector() {
    userGraph = new HashMap<>();
    communityMap = new HashMap<>();
  }

  public void addUser(String userId, List<String> friends) {
    if (userId == null || userId.isEmpty() || friends == null) {
      throw new IllegalArgumentException("Inputs cannot be null or empty.");
    }
    userGraph.putIfAbsent(userId, new HashSet<>());
    for (String friend : friends) {
      if (friend == null || friend.isEmpty()) {
        continue;
      }
      userGraph.get(userId).add(friend);
      userGraph.putIfAbsent(friend, new HashSet<>());
      userGraph.get(friend).add(userId);
    }
  }

  public Map<String, Integer> detectCommunities() {
    int communityId = 0;
    for (String user : userGraph.keySet()) {
      if (!communityMap.containsKey(user)) {
        communityMap.put(user, communityId);
        exploreCommunity(user, communityId);
        communityId++;
      }
    }
    return communityMap;
  }

  private void exploreCommunity(String user, int communityId) {
    Queue<String> queue = new LinkedList<>();
    queue.add(user);

    while (!queue.isEmpty()) {
      String currentUser = queue.poll();
      for (String friend : userGraph.get(currentUser)) {
        if (!communityMap.containsKey(friend)) {
          communityMap.put(friend, communityId);
          queue.add(friend);
        }
      }
    }
  }

  public List<String> getCommunityMembers(int communityId) {
    if (communityId < 0) {
      throw new IllegalArgumentException("invalid communityId");
    }
    List<String> members = new ArrayList<>();
    for (Map.Entry<String, Integer> entry : communityMap.entrySet()) {
      if (entry.getValue() == communityId) {
        members.add(entry.getKey());
      }
    }
    return members;
  }
}

--TESTS---

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Map;

public class Main {
  public static void main(String[] args) {
    CommunityDetector detector = new CommunityDetector();

    //TEST
    detector.addUser("Alice", Arrays.asList("Bob", "Charlie"));
    detector.addUser("Bob", Arrays.asList("Alice", "David"));
    detector.addUser("Charlie", Arrays.asList("Alice"));
    detector.addUser("David", Arrays.asList("Bob"));
    detector.addUser("Eve", Arrays.asList("Frank"));
    detector.addUser("Frank", Arrays.asList("Eve"));

    Map<String, Integer> communities = detector.detectCommunities();
    assert communities.get("Alice").equals(communities.get("Charlie"));
    //TEST_END

    //TEST
    assert communities.get("Alice").equals(communities.get("David"));
    //TEST_END

    //TEST
    assert !communities.get("Alice").equals(communities.get("Eve"));
    //TEST_END

    //TEST
    detector.addUser("Isolated", new ArrayList<>());
    assert detector.detectCommunities().containsKey("Isolated");
    //TEST_END

    //TEST
    try {
      detector.addUser(null, Arrays.asList("Bob"));
      assert false;
    } catch (IllegalArgumentException e) {
      assert true;
    }
    //TEST_END

    //TEST
    try {
      detector.addUser("Tom", null);
      assert false;
    } catch (IllegalArgumentException e) {
      assert true;
    }
    //TEST_END

    //TEST
    List<String> community0 = detector.getCommunityMembers(0);
    assert community0.contains("Alice") && community0.contains("Bob");
    //TEST_END

    //TEST
    try {
      detector.getCommunityMembers(-1);
      assert false;
    } catch (IllegalArgumentException e) {
      assert true;
    }
    //TEST_END
  }
}

------------------------------------------------------------------------------------------------------------------------

21 - Rework from last week - brand new submission

Designing an algorithm to optimally distribute resources across a network of nodes,
ensuring that each node maintains a minimum required resource level. The network's connectivity and
each node's initial resources vary.

The system should have a class ResourceDistributor balance resource distribution across a connected graph in a way that minimizes
the total movement of resources while ensuring that no node falls below a specified minimum resource level.

Details:

Nodes represent different stations or entities that require resources to function.

Edges represent possible paths for resource transfer.

Each node has a current resource level and a minimum required resource level.

Resources can be moved between directly connected nodes.

required function signature:
public class ResourceDistributor {

  public void addNode(int nodeId, int currentResources, int minRequiredResources);

  public void addEdge(int nodeId1, int nodeId2);

  public void distributeResources();

  public Map<Integer, Integer> getNodeResourceLevels();
}


import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.atomic.AtomicBoolean;

public class ResourceDistributor {
  private Map<Integer, Node> nodes;
  private Map<Integer, List<Integer>> graph;

  public ResourceDistributor() {
    nodes = new HashMap<>();
    graph = new HashMap<>();
  }

  public void addNode(int nodeId, int currentResources, int minRequiredResources) {
    if (nodeId < 1 || currentResources < 1 || minRequiredResources < 1) {
      throw new IllegalArgumentException("invalid input");
    }
    nodes.put(nodeId, new Node(currentResources, minRequiredResources));
    graph.put(nodeId, new ArrayList<>());
  }

  public void addEdge(int nodeId1, int nodeId2) {
    if (nodeId1 < 1 || nodeId2 < 1) {
      throw new IllegalArgumentException("invalid input");
    }
    graph.get(nodeId1).add(nodeId2);
    graph.get(nodeId2).add(nodeId1);
  }

  public void distributeResources() {
    AtomicBoolean needsAdjustment = new AtomicBoolean(false);
    do {
      needsAdjustment.set(false);
      Map<Integer, Integer> allocations = new HashMap<>();

      for (Map.Entry<Integer, List<Integer>> entry : graph.entrySet()) {
        int nodeId = entry.getKey();
        Node currentNode = nodes.get(nodeId);
        int excess = currentNode.currentResources - currentNode.minRequiredResources;

        if (excess > 0) {
          List<Integer> neighbors = entry.getValue();
          int totalNeeded = 0;

          for (int neighborId : neighbors) {
            Node neighbor = nodes.get(neighborId);
            int needed = Math.max(0, neighbor.minRequiredResources - neighbor.currentResources);
            totalNeeded += needed;
          }

          for (int neighborId : neighbors) {
            Node neighbor = nodes.get(neighborId);
            if (totalNeeded > 0) {
              int needed = Math.max(0, neighbor.minRequiredResources - neighbor.currentResources);
              int give = (int) ((double) needed / totalNeeded * excess);

              allocations.put(neighborId, allocations.getOrDefault(neighborId, 0) + give);
              currentNode.currentResources -= give;
            }
          }
        }
      }

      allocations.forEach((id, allocation) -> {
        Node node = nodes.get(id);
        node.currentResources += allocation;
        if (node.currentResources >= node.minRequiredResources) {
          needsAdjustment.set(true);
        }
      });

    } while (needsAdjustment.get());
  }


  public Map<Integer, Integer> getNodeResourceLevels() {
    Map<Integer, Integer> resourceLevels = new HashMap<>();
    for (Map.Entry<Integer, Node> entry : nodes.entrySet()) {
      resourceLevels.put(entry.getKey(), entry.getValue().currentResources);
    }
    return resourceLevels;
  }

  static class Node {
    int currentResources;
    int minRequiredResources;

    Node(int currentResources, int minRequiredResources) {
      this.currentResources = currentResources;
      this.minRequiredResources = minRequiredResources;
    }
  }
}

--- TESTS ---

public class Main {
  public static void main(String[] args) {
    ResourceDistributor distributor = new ResourceDistributor();

    //TEST
    distributor.addNode(1, 100, 80);
    distributor.addNode(2, 30, 50);
    distributor.addEdge(1, 2);
    distributor.distributeResources();

    assert distributor.getNodeResourceLevels().get(1) >= 80;
    //TEST_END

    //TEST
    try {
      distributor.addEdge(1, -2);
      assert false;
    } catch (IllegalArgumentException e) {
      assert true;
    }
    //TEST_END

    //TEST
    try {
      distributor.addEdge(1, 0);
      assert false;
    } catch (IllegalArgumentException e) {
      assert true;
    }
    //TEST_END

    //TEST
    assert distributor.getNodeResourceLevels().get(2) >= 50;
    //TEST_END

    //TEST
    distributor.addNode(3, 60, 60);
    distributor.addEdge(2, 3);
    distributor.distributeResources();
    assert distributor.getNodeResourceLevels().get(3) == 60;
    //TEST_END

    //TEST
    distributor.addNode(4, 40, 30);
    distributor.addNode(5, 50, 50);
    distributor.addEdge(4, 5);
    distributor.distributeResources();

    assert distributor.getNodeResourceLevels().get(4) >= 30;
    //TEST_END

    //TEST
    assert distributor.getNodeResourceLevels().get(5) == 50;
    //TEST_END

    //TEST
    try {
      distributor.addNode(6, -10, 20);
      assert false;
    } catch (IllegalArgumentException e) {
      assert true;
    }
    //TEST_END

    //TEST
    try {
      distributor.addNode(0, 10, 20);
      assert false;
    } catch (IllegalArgumentException e) {
      assert true;
    }
    //TEST_END

    //TEST
    try {
      distributor.addNode(1, 1, 0);
      assert false;
    } catch (IllegalArgumentException e) {
      assert true;
    }
    //TEST_END

    //TEST: Check distribution after adding edges between multiple nodes
    distributor.addNode(7, 25, 25);
    distributor.addEdge(5, 7);
    distributor.distributeResources();
    assert distributor.getNodeResourceLevels().get(7) == 25;
    //TEST_END
  }
}

------------------------------------------------------------------------------------------------------------------------

22 - Rework from last week - brand new submission

Create an algorithm to optimize network traffic routing in a telecommunications network.
 Each node in the network represents a switch or router, and each edge represents a communication link with a certain
 capacity (maximum traffic it can handle).

Develop a system that optimizes the flow of data packets across the network to minimize the total transmission time
 while avoiding overloading any single link.

Nodes in the network can generate or receive data packets.
Each link between nodes has a capacity limit.
Data packets have a size and a destination, and they can be routed through multiple paths.

Implement the NetworkTrafficOptimizer class that takes a graph representing the network, analyzes possible paths, and
 distributes traffic in a way that maximizes efficiency and minimizes transmission delays.

Function Signature:

public class NetworkTrafficOptimizer {

  public void addNode(String nodeId);

  public void addLink(String nodeId1, String nodeId2, int capacity);

  public void routePacket(String source, String destination, int packetSize);

  public Map<String, Integer> getCurrentLoadOnLinks();
}


import java.util.HashMap;
import java.util.Map;

public class NetworkTrafficOptimizer {
  private Map<String, Map<String, Integer>> graph;
  private Map<String, Integer> capacity;
  private Map<String, Integer> linkLoad;

  public NetworkTrafficOptimizer() {
    this.graph = new HashMap<>();
    this.capacity = new HashMap<>();
    this.linkLoad = new HashMap<>();
  }

  public void addNode(String nodeId) {
    if (nodeId == null || nodeId.isEmpty()) {
      throw new IllegalArgumentException("Invalid input");
    }
    graph.putIfAbsent(nodeId, new HashMap<>());
  }

  public void addLink(String nodeId1, String nodeId2, int capacity) {
    if (nodeId1 == null || nodeId1.isEmpty() || nodeId2 == null || nodeId2.isEmpty() || capacity <= 0) {
      throw new IllegalArgumentException("Invalid input");
    }
    graph.get(nodeId1).put(nodeId2, capacity);
    graph.get(nodeId2).put(nodeId1, capacity);
    String link1 = nodeId1 + "->" + nodeId2;
    String link2 = nodeId2 + "->" + nodeId1;
    this.capacity.put(link1, capacity);
    this.capacity.put(link2, capacity);
    linkLoad.put(link1, 0);
    linkLoad.put(link2, 0);
  }

  public void routePacket(String source, String destination, int packetSize) {
    if (source == null || source.isEmpty() || destination == null || destination.isEmpty() || packetSize <= 0) {
      throw new IllegalArgumentException("Invalid input");
    }
    String directLink = source + "->" + destination;
    if (linkLoad.get(directLink) + packetSize > capacity.get(directLink) * 0.8) {
      String alternatePath1 = source + "->B";
      String alternatePath2 = "B->" + destination;

      if (linkLoad.get(alternatePath1) + packetSize <= capacity.get(alternatePath1) &&
          linkLoad.get(alternatePath2) + packetSize <= capacity.get(alternatePath2)) {
        linkLoad.put(alternatePath1, linkLoad.get(alternatePath1) + packetSize);
        linkLoad.put(alternatePath2, linkLoad.get(alternatePath2) + packetSize);
      } else {
        if (linkLoad.get(directLink) + packetSize <= capacity.get(directLink)) {
          linkLoad.put(directLink, linkLoad.get(directLink) + packetSize);
        }
      }
    } else {
      linkLoad.put(directLink, linkLoad.get(directLink) + packetSize);
    }
  }

  public Map<String, Integer> getCurrentLoadOnLinks() {
    return new HashMap<>(linkLoad);
  }
}


---- TESTS ----
import java.util.Map;

public class Main {
  public static void main(String[] args) {
    testBasicConnectivity();
    testCapacityLimits();
    testShortestPathRouting();
  }

  private static void testBasicConnectivity() {
    NetworkTrafficOptimizer optimizer = new NetworkTrafficOptimizer();
    optimizer.addNode("A");
    optimizer.addNode("B");
    optimizer.addLink("A", "B", 100);

    optimizer.routePacket("A", "B", 50);

    //TEST
    Map<String, Integer> load = optimizer.getCurrentLoadOnLinks();
    assert load.get("A->B") == 50;
    //TEST_END

    //TEST
    try {
      optimizer.addNode("");
      assert false;
    } catch (IllegalArgumentException e) {
      assert true;
    }
    //TEST_END

    //TEST
    try {
      optimizer.addNode(null);
      assert false;
    } catch (IllegalArgumentException e) {
      assert true;
    }
    //TEST_END

    //TEST
    try {
      optimizer.addLink("", "B", 100);
      assert false;
    } catch (IllegalArgumentException e) {
      assert true;
    }
    //TEST_END

    //TEST
    try {
      optimizer.addLink("A", null, 100);
      assert false;
    } catch (IllegalArgumentException e) {
      assert true;
    }
    //TEST_END

    //TEST
    try {
      optimizer.addLink("A", "B", -4);
      assert false;
    } catch (IllegalArgumentException e) {
      assert true;
    }
    //TEST_END

    //TEST
    try {
      optimizer.routePacket("", "B", 100);
      assert false;
    } catch (IllegalArgumentException e) {
      assert true;
    }
    //TEST_END

    //TEST
    try {
      optimizer.routePacket("A", null, 100);
      assert false;
    } catch (IllegalArgumentException e) {
      assert true;
    }
    //TEST_END

    //TEST
    try {
      optimizer.routePacket("A", "B", -4);
      assert false;
    } catch (IllegalArgumentException e) {
      assert true;
    }
    //TEST_END
  }

  private static void testCapacityLimits() {
    NetworkTrafficOptimizer optimizer = new NetworkTrafficOptimizer();
    optimizer.addNode("A");
    optimizer.addNode("B");
    optimizer.addLink("A", "B", 50);

    optimizer.routePacket("A", "B", 30);
    optimizer.routePacket("A", "B", 30);

    //TEST
    Map<String, Integer> load = optimizer.getCurrentLoadOnLinks();
    assert load.get("A->B") <= 50;
    //TEST_END
  }

  private static void testShortestPathRouting() {
    NetworkTrafficOptimizer optimizer = new NetworkTrafficOptimizer();
    optimizer.addNode("A");
    optimizer.addNode("B");
    optimizer.addNode("C");
    optimizer.addLink("A", "B", 100);
    optimizer.addLink("B", "C", 100);
    optimizer.addLink("A", "C", 50);

    optimizer.routePacket("A", "C", 25);

    //TEST
    Map<String, Integer> load = optimizer.getCurrentLoadOnLinks();
    assert load.get("A->C") == 25;
    //TEST_END
  }
}


------------------------------------------------------------------------------------------------------------------------

23 - Rework from last week - brand new submission

Design a Java class to simulate the dynamic behavior of gene expression pathways in a biological system. In this simulation,
 each gene or protein acts as a node, and the interactions (like activation or inhibition) between them are edges with varying
 intensities based on external conditions like temperature or chemical presence.

**Requirements**
Class Name: GeneExpressionSimulator

**Method Signatures**

public void addGene(String geneId)

public void connectGenes(String geneId1, String geneId2, double baseInteractionStrength)

public void updateConditions(String geneId1, String geneId2, double currentConditionFactor)

public List<String> findOptimalSignalPath(String sourceGene, String targetGene)

**Functionality**

addGene: Registers a new gene in the system.

connectGenes: Establishes a biochemical interaction between two genes with a specified base interaction strength.

updateConditions: Modifies the interaction strength based on external biological conditions.

findOptimalSignalPath: Determines the most effective pathway for a signal to travel from the source gene to the target gene,
considering the current interaction strengths.



------------------------------------------------------------------------------------------------------------------------

24 - Rework from last week - brand new submission

**Problem**
Create a Java class to detect anomalies in historical climate data, focusing on temperature
fluctuations that significantly deviate from historical averages. This system will help
researchers identify unusual temperature events that could indicate significant climatic changes.

**Requirements**
Class Name: ClimateAnomalyDetector

**Method Signatures**:

public void addTemperatureRecord(String date, double temperature)

public List<String> detectAnomalies(double threshold)

**Functionality**:
addTemperatureRecord: Records the temperature for a given date.

detectAnomalies: Returns a list of dates where the temperature was outside the normal
range by more than the specified threshold percentage compared to the historical average.


import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class ClimateAnomalyDetector {
    private Map<String, Double> temperatureRecords;
    private double averageTemperature;

    public ClimateAnomalyDetector() {
        this.temperatureRecords = new HashMap<>();
        this.averageTemperature = 0.0;
    }

    public double getAverageTemperature(){
        return this.averageTemperature;
    }

    public void addTemperatureRecord(String date, double temperature) {
        if (date == null || date.isEmpty()) {
            throw new IllegalArgumentException("Date cannot be null or empty");
        }
        if (Double.isNaN(temperature) || Double.isInfinite(temperature)) {
            throw new IllegalArgumentException("Temperature must be a valid number");
        }
        temperatureRecords.put(date, temperature);
        updateAverageTemperature(temperature);
    }

    private void updateAverageTemperature(double newTemp) {
        averageTemperature = temperatureRecords.values().stream()
            .mapToDouble(Double::doubleValue)
            .average()
            .orElse(Double.NaN);
    }

    public List<String> detectAnomalies(double threshold) {
        if (threshold < 0) {
            throw new IllegalArgumentException("Threshold must be non-negative");
        }
        List<String> anomalies = new ArrayList<>();
        double lowerBound = averageTemperature * (1 - threshold);
        double upperBound = averageTemperature * (1 + threshold);

        for (Map.Entry<String, Double> entry : temperatureRecords.entrySet()) {
            double temp = entry.getValue();
            if (temp < lowerBound || temp > upperBound) {
                anomalies.add(entry.getKey());
            }
        }
        return anomalies;
    }
}

--TESTS ---
import java.util.List;

public class Main {
    public static void main(String[] args) {
        ClimateAnomalyDetector detector = new ClimateAnomalyDetector();
        detector.addTemperatureRecord("2021-01-01", 20.0);
        detector.addTemperatureRecord("2021-01-02", 22.0);
        detector.addTemperatureRecord("2021-01-03", 18.0);

        //TEST
        double expectedAverage = (20.0 + 22.0 + 18.0) / 3;
        assert Math.abs(detector.getAverageTemperature() - expectedAverage) < 0.01;
        //TEST_END

        detector.addTemperatureRecord("2021-01-04", 30.0);
        //TEST
        List<String> anomalies = detector.detectAnomalies(0.20);
        assert anomalies.contains("2021-01-04");
        assert anomalies.size() == 1;
        //TEST_END


        //TEST
        try {
            detector.addTemperatureRecord(null, 20.0);
            assert false;
        } catch (IllegalArgumentException e) {
            assert true;
        }
        //TEST_END

        //TEST
        try {
            detector.addTemperatureRecord("", 20.0);
            assert false;
        } catch (IllegalArgumentException e) {
            assert true;
        }
        //TEST_END

        //TEST
        try {
            detector.addTemperatureRecord("2021-01-05", Double.NaN);
            assert false;
        } catch (IllegalArgumentException e) {
            assert true;
        }
        //TEST_END

        //TEST
        try {
            detector.detectAnomalies(-0.1);
            assert false;
        } catch (IllegalArgumentException e) {
            assert true;
        }
        //TEST_END
    }
}


------------------------------------------------------------------------------------------------------------------------

25 - Rework from last week - brand new submission


